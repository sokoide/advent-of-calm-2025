# CALM Architecture Definition in Go

このディレクトリには、CALM アーキテクチャを Go で定義・生成するための DSL 実装が含まれています。JSON を手書きするのではなく、Go の型安全性を活かした「アーキテクチャのコーディング」を目的としています。

## なぜ Go で書くのか？ — 構成（Config）から開発（Coding）へ

静的な JSON や YAML の編集は「作業」になりがちですが、Go DSL を使うことでアーキテクチャ設計は「創造的な開発」へと進化します。

- **圧倒的な書き心地 (DX)**: 強力な IDE の補完、リファクタリングツール、定義へのジャンプなど、モダンな開発環境の恩恵をフルに受けられます。
- **「実行するまでエラーがわからない」からの脱却**: Typo や型違いはエディタが即座に指摘し、不整合はビルド時に検出されます。
- **ロジックによる表現**: ループや条件分岐、変数を駆使することで、巨大なシステムも簡潔かつ知的に記述できます。
- **なによりも、楽しい**: 「巨大な JSON と格闘する」ストレスから解放され、「Go でスマートに設計図を組む」楽しさを享受できます。

## 主な改善点

- **Functional Options パターン**: `DefineNode` において `WithOwner` や `WithMeta` を使った宣言的な定義が可能になりました。
- **メタデータの部品化 (Composition)**: `Merge` ヘルパーにより、共通のメタデータ部品（Tier1, DBA, ManagedService 等）を組み合わせてノードを構築できます。
- **Fluent Connection API**: `node.ConnectTo(dest)` 形式の直感的な配線と、`LinksContainer` による関係の構造化管理を導入しました。
- **型安全なフロー構築**: 文字列 ID への依存を減らし、リレーションシップオブジェクトやその `GetID()` メソッドを介してフローを定義できます。
- **`owner` の一元管理 (SSoT)**: `WithOwner` でトップレベルの `owner` に集約し、`metadata` 側の重複を避けてドリフトを防ぎます。
- **動的コンポーネント対応**: ゲートウェイの数や ID を変更しても、依存関係 (`dependencies`) やフロー定義が自動的に追随します。

## "Architecture as Code" による一貫性とメンテナンス性の向上

### 用語解説 (Glossary)

- **SSoT (Single Source of Truth / 単一の真実のソース)**: データの正解を 1 箇所のみに集約し、重複や不整合を排除する設計原則。
- **DRY (Don't Repeat Yourself / 重複を避けよ)**: 同じ意味の情報を重複して持たせず、一箇所の変更が正しく全体に波及するようにする原則。
- **DX (Developer Experience / 開発者体験)**: 開発者がツールやコードを使って目的を達成する際の「書き心地」や効率性の総称。

JSON を手書きする場合と比較して、Go DSL を使用することでアーキテクチャの品質を劇的に高めることができます。

### 1. 単一の真実のソース (SSoT) による一貫性の強制

JSON では `owner` を複数箇所に持たせがちで、更新漏れの原因になります。本 DSL は `owner` をトップレベルに集約し、`metadata` には重複させない方針です。もし下流ツールが `metadata["owner"]` を要求する場合は、対象ノードだけ `WithMeta` で明示的に追加してください。

この方針に合わせて、リポジトリ内の参照用 JSON (`architectures/ecommerce-platform.json`) も Go DSL の出力結果で同期されています。

例えば、下流ツールの互換性のために `metadata["owner"]` を付与したい場合は、次のような差分になります。

```diff
     {
       "unique-id": "customer",
       "name": "Customer",
+      "metadata": {
+        "owner": "marketing-team"
+      },
       "owner": "marketing-team"
     }
```

### 2. 動的スケーリングと整合性の自動維持

JSON では、ゲートウェイの数を増やすだけで、ノード定義、依存関係リスト、配線（Relationships）、フロー定義のステップなど、数十箇所の修正が必要になり、整合性を欠くリスクが非常に高いです。

Go DSL では、定数（例：`numGateways`）を一つ変更するだけで、システム全体の整合性を保ったままアーキテクチャを自動的に再構成できます。

### 2. 「設計書」としてのコードと意思決定の追跡

Go で記述されたアーキテクチャは、単なる生成ツールではなく「設計書」そのものです。例えば「ゲートウェイを 2 台にする」という決定は、単なる設定値ではなく重要な**設計上の意思決定**です。

これをコード上の定数として明示的に固定することで、以下のようなメリットが得られます。

- **意思決定の明文化**: `const numGateways = 2` と記述することで、設計意図がコードから直接読み取れます。
- **Git による変更履歴の追跡**: 「なぜ 1 台から 2 台に増やしたのか」という設計変更の経緯を、Pull Request やコミットメッセージと共に Git の履歴として正確に記録・追跡できます。
- **スケーラビリティの保証**: 定数を変更するだけで、依存関係、配線、フローが矛盾なく再計算されるため、将来の拡張時もモデルの整合性が保証されます。

```go
// 2025-12-27: 高可用性確保のためゲートウェイを2台に増強
const numGateways = 2
```

### 3. メタデータの部品化による重複排除 (DRY)

複雑な運用情報（Tier, On-Call, Backup 設定等）を複数のノードに記述する際、JSON ではコピー＆ペーストが常態化し、一部の設定漏れや不整合が発生します。

Go では共通設定を「部品」として定義し、マージすることで、一箇所を修正すればすべてのノードに反映される安全な構成管理が可能です。

```go
metaOps = map[string]any{"oncall": "#oncall-ops"}
// 複数のノードで再利用、衝突時は Go がパニックで知らせてくれる
a.DefineNode("svc", Service, ..., WithMeta(Merge(metaTier1, metaOps)))
```

### 4. リレーションシップの構造化管理と型安全な参照

JSON のフロー定義は「文字列 ID の羅列」であり、リレーションシップ ID が変更されても気づくことができず、モデルが壊れる原因となります。

Go では `LinksContainer` 構造体ですべての接続を管理し、コード上の変数として参照するため、IDE の補完が効き、存在しない ID の参照はコンパイルエラーとして検出されます。

```go
// IDE で補完が効き、Typo はコンパイル時に防げる
fb.Step(lc.OrderToInv.GetID(), "Checking inventory")
```

### 5. フロー定義による「冗長性」と「分散」の証明

CALM のフロー定義は、システム内の膨大な通信パターンから代表的なものを切り出した「サンプル」です。

現在の DSL 実装では、注文フローと在庫確認フローで意図的に異なるゲートウェイ・インスタンスを使用しています。これは「フローごとに専用のゲートウェイが必要」という物理的な制約ではなく、**設計書（ドキュメント）として以下のメッセージを表現するため**の意図的なモデリング手法です。

- **高可用性 (HA) の視覚化**: 複数のゲートウェイが単なる待機系ではなく、実際に稼働（Active-Active）していることを示します。
- **負荷分散 (Load Balancing) の表現**: Load Balancer がリクエストを複数のインスタンスへ適切に振り分けている様子を、異なるフローの軌跡として描きます。
- **配線の網羅性確認**: すべての物理的な接続（リレーションシップ）が、少なくとも一つのビジネスプロセスで使用されていることを証明し、「どこにも繋がっていない死んだ部品」がないことを保証します。

DSL では「フローのレシピ（手順）」と「使用するインスタンス」を分離して定義しているため、これらの複雑な表現を整合性を保ったまま自動生成できます。

## 比較：手書き JSON vs. Go DSL (Architecture as Code)

アーキテクチャ設計における「メンテナンス性」と「開発の楽しさ」の観点から、従来の手法と Go DSL を比較します。

### 1. メンテナンス性と信頼性

| 観点                 | CALM 標準 JSON (手書き)                              | Go による DSL (Code)                                       |
| :------------------- | :--------------------------------------------------- | :--------------------------------------------------------- |
| **スケーラビリティ** | ゲートウェイを増やすだけで数十箇所の修正が必要。     | 定数を一つ変えるだけで全整合性が自動計算される。           |
| **整合性の保証**     | 重複記述が多く、修正漏れによる不整合が防げない。     | **SSoT** により、一箇所の定義が全体へ波及・同期される。    |
| **重複の排除 (DRY)** | コピー＆ペーストが常態化し、モデルが肥大化する。     | **Composition** により、共通設定を部品としてマージできる。 |
| **リファクタリング** | 文字列置換に頼るしかなく、ミスでモデルが壊れやすい。 | IDE が安全に更新し、不整合はコンパイラが検出する。         |

### 2. 開発者体験 (DX) と「楽しさ」

| 観点               | CALM 標準 JSON (手書き)                        | Go による DSL (Code)                                     |
| :----------------- | :--------------------------------------------- | :------------------------------------------------------- |
| **書き心地**       | カッコやコンマの有無に神経を使う「設定作業」。 | IDE の強力な補完により、「流れるように」設計できる。     |
| **フィードバック** | ツール実行までミスに気づけない（遅い）。       | エディタが即座にエラーを指摘する（即時フィードバック）。 |
| **表現の自由度**   | 静的な宣言のみ。                               | ループ、条件分岐、関数を駆使して知的に構築できる。       |
| **達成感**         | 「作業が終わった」という安堵感。               | 「美しいプログラムを書いた」という技術的な喜び。         |

### 総評：設計を「プログラミング」する価値

今回の Go DSL への移行は、単なる JSON 生成ツールの作成ではありません。**「動くコード（実装）」と同じ熱量で「語るコード（設計図）」を書けるようにすること**が真の目的です。

人間が手作業で整合性を保つストレスから解放され、Go の表現力を借りてシステムの構造をスマートに解き明かしていく。この「創造的な開発体験」こそが、Architecture as Code がもたらす最大の価値です。

## DSL 命名規則 (Naming Conventions)

| 接頭辞 / メソッド              | 役割                    | 説明                                                                      | 例                                           |
| :----------------------------- | :---------------------- | :------------------------------------------------------------------------ | :------------------------------------------- |
| **`New...`**                   | **独立した部品の生成**  | 親が決まっていない単体の部品を作成します。                                | `NewRequirement`, `NewSecurityConfig`        |
| **`Define...`**                | **宣言的生成 (Modern)** | Functional Options を受け取り、高度に構成されたオブジェクトを生成します。 | `arch.DefineNode()`, `arch.DefineFlow()`     |
| **`With...`**                  | **オプション設定**      | `Define...` メソッドに渡すための設定関数です。                            | `WithOwner()`, `WithMeta()`, `WithControl()` |
| **`ConnectTo`**                | **ノード中心の接続**    | ノード自身から接続を開始し、Builder を返します。                          | `node.ConnectTo(dest)`                       |
| **`Via` / `Is` / `Encrypted`** | **属性の設定 (Fluent)** | オブジェクトのプロパティを流れるように設定します。                        | `rel.Via("src", "dst").Encrypted(true)`      |
| **`Steps` / `MetaMap`**        | **一括設定 (Bulk)**     | リストやマップを使って複数の属性を一発で設定します。                      | `fb.Steps(specs...)`, `fb.MetaMap(m)`        |
| **`Merge`**                    | **メタデータの合成**    | 複数のマップを一つにまとめます。キー衝突時はパニックします。              | `Merge(metaTier1, metaOps)`                  |

## 開発者向けツール

本 DSL には、開発体験を向上させる複数のツールが付属しています。

### ライブサーバー (Hot Reload)

Go ファイルを編集すると、ブラウザでアーキテクチャ図が自動更新されます。

```bash
# Mermaid ダイアグラムで表示
make watch

# D2 ダイアグラムで表示 (より美しいレンダリング)
make watch-d2
```

ブラウザで `http://localhost:3000` を開くと、リアルタイムでアーキテクチャ図が表示されます。

### D2 ダイアグラム生成

[D2](https://d2lang.com/) 形式のダイアグラムを生成できます。

```bash
make d2
# → architecture.d2 と architecture.svg を生成
```

D2 CLI のインストール: `brew install d2`

### バリデーション DSL

アーキテクチャの品質を自動検証するルールが組み込まれています。

```bash
make check
# → ✅ All validation rules passed
```

**組み込みルール:**

- `AllNodesHaveOwner()` - 全ノードに owner が設定されている
- `AllServicesHaveHealthEndpoint()` - サービスに health-endpoint がある
- `NoDanglingRelationships()` - 存在しないノードへの参照がない
- `AllFlowsHaveValidTransitions()` - フローのステップが有効
- `AllDatabasesHaveBackupSchedule()` - データベースに backup-schedule がある
- `AllTier1NodesHaveRunbook()` - tier-1 ノードに runbook がある

### アーキテクチャ差分ツール

2 つの CALM JSON を比較し、意味的な差分をカラー表示します。

```bash
make diff-arch
```

表示される差分:

- 📦 Nodes: 追加/削除/変更
- 🔗 Relationships: 追加/削除
- 🌊 Flows: 追加/削除
- 🛡️ Controls: 追加/削除

## 使用方法

```bash
# フォーマット (120文字制限適用)
make format

# CALM スキーマバリデーション
make validate

# Go DSL バリデーションルール
make check

# オリジナル JSON との比較 (diff が出なければ成功)
make diff

# 意味的なアーキテクチャ差分を表示
make diff-arch

# D2 ダイアグラム生成
make d2

# ライブサーバー (Mermaid)
make watch

# ライブサーバー (D2)
make watch-d2
```
