# CALM Architecture Definition in Go

このディレクトリには、CALM アーキテクチャを Go で定義・生成するための DSL 実装が含まれています。JSON を手書きするのではなく、Go の型安全性を活かした「アーキテクチャのコーディング」を目的としています。

## なぜ Go で書くのか？ — 構成（Config）から開発（Coding）へ

静的な JSON や YAML の編集は「作業」になりがちですが、Go DSL を使うことでアーキテクチャ設計は「創造的な開発」へと進化します。

- **圧倒的な書き心地 (DX)**: 強力な IDE の補完、リファクタリングツール、定義へのジャンプなど、モダンな開発環境の恩恵をフルに受けられます。
- **「実行するまでエラーがわからない」からの脱却**: Typo や型違いはエディタが即座に指摘し、不整合はビルド時に検出されます。
- **ロジックによる表現**: ループや条件分岐、変数を駆使することで、巨大なシステムも簡潔かつ知的に記述できます。
- **なによりも、楽しい**: 「巨大な JSON と格闘する」ストレスから解放され、「Go でスマートに設計図を組む」楽しさを享受できます。

## 主な改善点 (Recent Improvements)

- **Functional Options パターン**: `DefineNode` において `WithOwner` や `WithMeta` を使った宣言的な定義が可能になりました。
- **メタデータの部品化 (Composition)**: `Merge` ヘルパーにより、共通のメタデータ部品（Tier1, DBA, ManagedService等）を組み合わせてノードを構築できます。
- **Fluent Connection API**: `node.ConnectTo(dest)` 形式の直感的な配線と、`LinksContainer` による関係の構造化管理を導入しました。
- **型安全なフロー構築**: 文字列 ID への依存を減らし、リレーションシップオブジェクトやその `GetID()` メソッドを介してフローを定義できます。
- **`owner` の一元管理 (SSoT)**: `WithOwner` オプションにより、トップレベルの `owner` フィールドと `metadata["owner"]` の両方が自動的に同期されます。
- **動的コンポーネント対応**: ゲートウェイの数や ID を変更しても、依存関係 (`dependencies`) やフロー定義が自動的に追随します。

## "Architecture as Code" による一貫性とメンテナンス性の向上

### 用語解説 (Glossary)

- **SSoT (Single Source of Truth / 単一の真実のソース)**: データの正解を1箇所のみに集約し、重複や不整合を排除する設計原則。
- **DRY (Don't Repeat Yourself / 重複を避けよ)**: 同じ意味の情報を重複して持たせず、一箇所の変更が正しく全体に波及するようにする原則。
- **DX (Developer Experience / 開発者体験)**: 開発者がツールやコードを使って目的を達成する際の「書き心地」や効率性の総称。

JSON を手書きする場合と比較して、Go DSL を使用することでアーキテクチャの品質を劇的に高めることができます。

### 1. 単一の真実のソース (SSoT) による一貫性の強制

CALM の現在のスキーマ仕様（v1.x）は完全には正規化されておらず、`owner` 情報が「Node 直下のフィールド」と「`metadata` 内のキー」の両方に存在することが一般的です。これは多くの外部ツールやドキュメント生成ツールとの互換性のために必要とされています。

Go DSL では、この仕様上の妥協をプログラムレベルで吸収します。`WithOwner` オプションを使用するだけで、トップレベルの `owner` と `metadata["owner"]` の両方が常に同じ値で自動的に同期されます。これにより、二重管理による不整合のリスクを完全に排除しています。

最新の DSL では、以前の（一部欠落があった）JSON と比較すると以下のような品質向上のための差分が発生します。

```diff
     {
       "unique-id": "customer",
       "name": "Customer",
+      "metadata": {
+        "owner": "marketing-team"
+      },
       "owner": "marketing-team"
     }
```

この一貫性の向上に合わせて、リポジトリ内の参照用 JSON (`architectures/ecommerce-platform.json`) も Go DSL の出力結果で完全に同期・更新されています。

### 2. 動的スケーリングと整合性の自動維持

JSON では、ゲートウェイの数を増やすだけで、ノード定義、依存関係リスト、配線（Relationships）、フロー定義のステップなど、数十箇所の修正が必要になり、整合性を欠くリスクが非常に高いです。

Go DSL では、定数（例：`numGateways`）を一つ変更するだけで、システム全体の整合性を保ったままアーキテクチャを自動的に再構成できます。

### 2. 「設計書」としてのコードと意思決定の追跡

Go で記述されたアーキテクチャは、単なる生成ツールではなく「設計書」そのものです。例えば「ゲートウェイを2台にする」という決定は、単なる設定値ではなく重要な**設計上の意思決定**です。

これをコード上の定数として明示的に固定することで、以下のようなメリットが得られます。

- **意思決定の明文化**: `const numGateways = 2` と記述することで、設計意図がコードから直接読み取れます。
- **Git による変更履歴の追跡**: 「なぜ1台から2台に増やしたのか」という設計変更の経緯を、Pull Request やコミットメッセージと共に Git の履歴として正確に記録・追跡できます。
- **スケーラビリティの保証**: 定数を変更するだけで、依存関係、配線、フローが矛盾なく再計算されるため、将来の拡張時もモデルの整合性が保証されます。

```go
// 2025-12-27: 高可用性確保のためゲートウェイを2台に増強
const numGateways = 2 
```

### 3. メタデータの部品化による重複排除 (DRY)

複雑な運用情報（Tier, On-Call, Backup設定等）を複数のノードに記述する際、JSON ではコピー＆ペーストが常態化し、一部の設定漏れや不整合が発生します。

Go では共通設定を「部品」として定義し、マージすることで、一箇所を修正すればすべてのノードに反映される安全な構成管理が可能です。

```go
metaOps = map[string]any{"oncall": "#oncall-ops"}
// 複数のノードで再利用、衝突時は Go がパニックで知らせてくれる
a.DefineNode("svc", Service, ..., WithMeta(Merge(metaTier1, metaOps)))
```

### 3. リレーションシップの構造化管理と型安全な参照

JSON のフロー定義は「文字列 ID の羅列」であり、リレーションシップ ID が変更されても気づくことができず、モデルが壊れる原因となります。

Go では `LinksContainer` 構造体ですべての接続を管理し、コード上の変数として参照するため、IDE の補完が効き、存在しない ID の参照はコンパイルエラーとして検出されます。

```go
// IDE で補完が効き、Typo はコンパイル時に防げる
fb.Step(lc.OrderToInv.GetID(), "Checking inventory")
```

## DSL 命名規則 (Naming Conventions)

| 接頭辞 / メソッド | 役割 | 説明 | 例 |
| :--- | :--- | :--- | :--- |
| **`New...`** | **独立した部品の生成** | 親が決まっていない単体の部品を作成します。 | `NewRequirement`, `NewSecurityConfig` |
| **`Define...`** | **宣言的生成 (Modern)** | Functional Options を受け取り、高度に構成されたオブジェクトを生成します。 | `arch.DefineNode()`, `arch.DefineFlow()` |
| **`With...`** | **オプション設定** | `Define...` メソッドに渡すための設定関数です。 | `WithOwner()`, `WithMeta()`, `WithControl()` |
| **`ConnectTo`** | **ノード中心の接続** | ノード自身から接続を開始し、Builder を返します。 | `node.ConnectTo(dest)` |
| **`Via` / `Is` / `Encrypted`** | **属性の設定 (Fluent)** | オブジェクトのプロパティを流れるように設定します。 | `rel.Via("src", "dst").Encrypted(true)` |
| **`Steps` / `MetaMap`** | **一括設定 (Bulk)** | リストやマップを使って複数の属性を一発で設定します。 | `fb.Steps(specs...)`, `fb.MetaMap(m)` |
| **`Merge`** | **メタデータの合成** | 複数のマップを一つにまとめます。キー衝突時はパニックします。 | `Merge(metaTier1, metaOps)` |

## 使用方法

```bash
# フォーマット (120文字制限適用)
make -C go format

# バリデーション (CALM スキーマチェック)
make -C go validate

# オリジナル JSON との比較 (diff が出なければ成功)
make -C go diff
```
